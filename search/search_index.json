{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VIPickle","text":"<p>vipickle is tiny python package for saving instances with unpickable attributes and restore them later.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>vipickle</code> with pip :</p> <pre><code>pip install vipickle\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Inherit from <code>VIPicklable</code> to add saving and reloading capabilites to yours objects even if they have unpickable attributes.</p> <pre><code>from vipickle import VIPicklable\nclass MyClass(VIPicklable):\nPICKLE_BLACKLIST = [\"unpicklable_attribute\"]\ndef __init__(self):\nself.unpicklable_attribute = \"do_not_pickle\"\ndef _dump_unpicklable_attribute_(self, save_dir: Path, overwrite:bool = True):\nprint(\"unpicklable_attribute won't be pickled but we could have saved it another way\")\ndef _restore_unpicklable_attribute_(self, save_dir: Path):\nself.unpicklable_attribute = \"attribute_restored\"\n# Create an instance\nobj = Myclass()\nassert obj.unpicklable_attribute == \"do_not_pickle\"\n# Save it : _dump_unpicklable_attribute_ will print a message\nobj.save(\"a/folder\")\ndel obj\n# Reload the object instance : _restore_unpicklable_attribute_ will set unpicklable_attribute\nobj = MyClass.load(\"a/folder\")\nassert obj.unpicklable_attribute == \"attribute_restored\"\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Blacklist of attributes that should not be pickled</li> <li>Dumping methods for blacklisted attributes</li> <li>Loading methods for blacklisted attributes</li> <li>List of attributes to be saved in a JSON file</li> <li>Blacklist inheritance</li> </ul> <p>See Features section for more details</p>"},{"location":"#development","title":"Development","text":"<p>Clone the repository and create a virtual environement</p> <pre><code>git clone https://github.com/h4c5/vipickle\ncd vipickle\npython -m venv .venv\n</code></pre> <p>Activate the virtual environment and install dev dependencies :</p> <pre><code>source .venv/bin/activate\npip install vipickle[dev]\n</code></pre> <p>Make modifications.</p> <p>To build the documentation, first install the documentation dependencies :</p> <pre><code>pip install vipickle[doc]\n</code></pre> <p>Then :</p> <pre><code>mkdocs serve # for local serving\nmkdocs build # to build documentation\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>VIPickle.</p> <p>VIPickle make any object picklable by specifying which attribute to blacklist when pickling and how to dump and recover them.</p>"},{"location":"reference/#vipickle.DumpAttributeError","title":"<code>DumpAttributeError</code>","text":"<p>         Bases: <code>AttributeError</code></p> <p>Use to indicate that the dumping method is not implemented.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/errors.py</code> <pre><code>class DumpAttributeError(AttributeError):\n\"\"\"Use to indicate that the dumping method is not implemented.\"\"\"\n</code></pre>"},{"location":"reference/#vipickle.MetaVIPicklable","title":"<code>MetaVIPicklable</code>","text":"<p>         Bases: <code>type</code></p> <p>Metaclass for VIPicklable.</p> <p>This metaclass is aimed to be used with VIPicklable class. It add the functionality to inherit attributes from the parent classes. Which is usefull for adding or removing attributes from PICKLE_BLACKLIST and CONFIG_ITEMS.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>class MetaVIPicklable(type):\n\"\"\"Metaclass for VIPicklable.\n    This metaclass is aimed to be used with VIPicklable class. It add the functionality\n    to inherit attributes from the parent classes. Which is usefull for adding or\n    removing attributes from PICKLE_BLACKLIST and CONFIG_ITEMS.\n    \"\"\"\ndef __new__(cls, name: str, parents: tuple, attributes: dict):\n\"\"\"Metaclass constructor.\n        Construct CONFIG_ITEMS and PICKLE_BLACKLIST.\n        Args:\n            name (str): Name of the class\n            parents (tuple): Parent classes\n            attributes (dict): Class attributes\n        \"\"\"\nfor prefix in (\"PICKLE_BLACKLIST\", \"CONFIG_ITEMS\"):\n# If the class has a prefix attribute, it will be used as it is\n# we convert it to a set to prevent duplicated values\nif prefix in attributes:\npickle_blacklist = {key for key in attributes[prefix]}\n# Otherwise the prefix attribute will be created from the parent classes\n# prefix attributes and the {prefix}_ADD and {prefix}_REMOVE attributes\nelse:\npickle_blacklist = set()\n# First we get the union of all pickle_blacklist of the parents\nfor parent in parents:\nif issubclass(parent, VIPicklable):\npickle_blacklist = pickle_blacklist.union(\ngetattr(parent, prefix, set())\n)\n# Then we add attributes from {prefix}_ADD\npickle_blacklist = pickle_blacklist.union(\nattributes.get(f\"{prefix}_ADD\", set())\n)\n# and we remove attributes from {prefix}_REMOVE\npickle_blacklist = pickle_blacklist.difference(\nattributes.get(f\"{prefix}_REMOVE\", set())\n)\n# Finnaly, {prefix} is converted to a tuple for immutablity\nattributes[prefix] = tuple(sorted(pickle_blacklist))\nreturn super().__new__(cls, name, parents, attributes)\n</code></pre>"},{"location":"reference/#vipickle.mixin.MetaVIPicklable.__new__","title":"<code>__new__(name, parents, attributes)</code>","text":"<p>Metaclass constructor.</p> <p>Construct CONFIG_ITEMS and PICKLE_BLACKLIST.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the class</p> required <code>parents</code> <code>tuple</code> <p>Parent classes</p> required <code>attributes</code> <code>dict</code> <p>Class attributes</p> required Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def __new__(cls, name: str, parents: tuple, attributes: dict):\n\"\"\"Metaclass constructor.\n    Construct CONFIG_ITEMS and PICKLE_BLACKLIST.\n    Args:\n        name (str): Name of the class\n        parents (tuple): Parent classes\n        attributes (dict): Class attributes\n    \"\"\"\nfor prefix in (\"PICKLE_BLACKLIST\", \"CONFIG_ITEMS\"):\n# If the class has a prefix attribute, it will be used as it is\n# we convert it to a set to prevent duplicated values\nif prefix in attributes:\npickle_blacklist = {key for key in attributes[prefix]}\n# Otherwise the prefix attribute will be created from the parent classes\n# prefix attributes and the {prefix}_ADD and {prefix}_REMOVE attributes\nelse:\npickle_blacklist = set()\n# First we get the union of all pickle_blacklist of the parents\nfor parent in parents:\nif issubclass(parent, VIPicklable):\npickle_blacklist = pickle_blacklist.union(\ngetattr(parent, prefix, set())\n)\n# Then we add attributes from {prefix}_ADD\npickle_blacklist = pickle_blacklist.union(\nattributes.get(f\"{prefix}_ADD\", set())\n)\n# and we remove attributes from {prefix}_REMOVE\npickle_blacklist = pickle_blacklist.difference(\nattributes.get(f\"{prefix}_REMOVE\", set())\n)\n# Finnaly, {prefix} is converted to a tuple for immutablity\nattributes[prefix] = tuple(sorted(pickle_blacklist))\nreturn super().__new__(cls, name, parents, attributes)\n</code></pre>"},{"location":"reference/#vipickle.RestoreAttributeError","title":"<code>RestoreAttributeError</code>","text":"<p>         Bases: <code>AttributeError</code></p> <p>Use to indicate that the restoring method is not implemented.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/errors.py</code> <pre><code>class RestoreAttributeError(AttributeError):\n\"\"\"Use to indicate that the restoring method is not implemented.\"\"\"\n</code></pre>"},{"location":"reference/#vipickle.VIPicklable","title":"<code>VIPicklable</code>","text":"<p>VIPicklable main class.</p> <p>Inherit from this class and define attributes to blacklist and the ones to add to the object configuration dict.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>class VIPicklable(metaclass=MetaVIPicklable):\n\"\"\"VIPicklable main class.\n    Inherit from this class and define attributes to blacklist and the ones to add to\n    the object configuration dict.\n    \"\"\"\nPICKLE_NAME: str = \"archive.pkl\"\nPICKLE_BLACKLIST: Iterable[str] = ()\nPICKLE_BLACKLIST_ADD: Iterable[str] = ()\nPICKLE_BLACKLIST_REMOVE: Iterable[str] = ()\nCONFIG_NAME: str = \"config.json\"\nCONFIG_ITEMS: Iterable[str] = ()\nCONFIG_ITEMS_ADD: Iterable[str] = ()\nCONFIG_ITEMS_REMOVE: Iterable[str] = ()\n@property\ndef configurations(self) -&gt; dict:\n\"\"\"A configuration dict used to show important attributes.\n        Returns:\n            dict: configuration dict\n        \"\"\"\nreturn {\nkey: getattr(self, key) for key in self.CONFIG_ITEMS if hasattr(self, key)\n}\ndef __getstate__(self):\n\"\"\"Pickle all attributes except the ones listed in PICKLE_BLACKLIST.\"\"\"\nreturn {\nattribute: state\nfor attribute, state in self.__dict__.items()\nif attribute not in self.PICKLE_BLACKLIST\n}\ndef save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n        Args:\n            path (Union[str, Path]): Path to the directory\n            pickle_dump_kwargs (dict, optional): kwargs to be passed to\n                pickle.dump method. Defaults to None.\n            json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n                Defaults to None.\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n        \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\ndef before_save(self):\n\"\"\"Hook executed at the beggining of the save method.\"\"\"\ndef after_save(self):\n\"\"\"Hook executed at the end of the save method.\"\"\"\ndef save_instance(self, path: Union[str, Path], overwrite: bool = True, **kwargs):\n\"\"\"Save the current instance.\n        Args:\n            path (Union[str, Path]): path to a folder where to save the current instance\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n            kwargs (dict, optional): Additional parameters. Default to {}.\n        \"\"\"\nif not self.PICKLE_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.PICKLE_NAME is empty so the instance \"\nf\"will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.PICKLE_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\npickle.dump(self, f, **kwargs)\ndef save_config(\nself,\npath: Union[str, Path],\noverwrite: bool = True,\noption: Optional[int] = orjson.OPT_INDENT_2,\ndefault: Optional[Callable[[Any], Any]] = ...,\n):\n\"\"\"Save the instance configuration attributes.\n        Args:\n            path (Union[str, Path]): path to a folder where to save the current instance\n                config file\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n            option (int, optional): ORJson options.\n                See [orjson documentation](https://github.com/ijl/orjson).\n                Defaults to orjson.OPT_INDENT_2.\n            default (Callable): To serialize a subclass or arbitrary types, specify\n                default as a callable that returns a supported type. default may be a\n                function, lambda, or callable class instance. To specify that a type was\n                not handled by default, raise an exception such as TypeError.\n        \"\"\"\nif not self.CONFIG_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.CONFIG_NAME is empty so the configuration \"\nf\"dict will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.CONFIG_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\nf.write(\norjson.dumps(self.configurations, default=default, option=option)\n)\ndef save_pickle_blacklisted(\nself, path: Union[str, Path], overwrite: bool = True\n) -&gt; Dict[str, Exception]:\n\"\"\"Try to save excluded attributes.\n        Args:\n            path (Union[str, Path]): path to a folder where to save blacklisted\n                attributes\n            overwrite (bool, optional): If True, overwrite the folder if it exists\n        Returns:\n            Dict[str, Exception]: A dictionary of attributes that could not be saved\n                and corresponding exceptions raised\n        \"\"\"\npath = create_folder(path)\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, DUMP_METHOD_PATTERN.format(attribute))(\npath, overwrite=overwrite\n)\nexcept DumpAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be dumped\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be dumped since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n@classmethod\ndef load_instance(cls, path: Union[str, Path], **kwargs) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n        Load an instance from a file or folder without unpicklable attributes.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n            kwargs (dict, optional): Additional parameters. Default to {}.\n        Raises:\n            FileNotFoundError: Pickle file not found\n        Returns:\n            VIPicklable: The instance object\n        \"\"\"\nwith open(path, \"rb\") as f:\nreturn pickle.load(f, **kwargs)\n@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n        Load a VIPicklable instance and all loadable attributes from a file or folder.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n            pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n                load_instance method. Default to None.\n        Raises:\n            FileNotFoundError: Pickle file not found\n        Returns:\n            VIPicklable: The instance object\n        \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n@classmethod\ndef before_load(cls):\n\"\"\"Hook executed at the beggining of the load method.\"\"\"\n@classmethod\ndef after_load(cls):\n\"\"\"Hook executed at the end of the load method.\"\"\"\ndef load_pickle_blacklisted(self, path: Union[str, Path]) -&gt; Dict[str, Exception]:\n\"\"\"Try to unpickle excluded attributes.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n        Returns:\n            Dict[str, Exception]: A dictionary of attributes that could not be loaded\n                and corresponding exceptions raised\n        \"\"\"\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, RESTORE_METHOD_PATTERN.format(attribute))(path)\nexcept RestoreAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be restored\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be unpickled since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.configurations","title":"<code>configurations: dict</code>  <code>property</code>","text":"<p>A configuration dict used to show important attributes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>configuration dict</p>"},{"location":"reference/#vipickle.mixin.VIPicklable.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Pickle all attributes except the ones listed in PICKLE_BLACKLIST.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def __getstate__(self):\n\"\"\"Pickle all attributes except the ones listed in PICKLE_BLACKLIST.\"\"\"\nreturn {\nattribute: state\nfor attribute, state in self.__dict__.items()\nif attribute not in self.PICKLE_BLACKLIST\n}\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.after_load","title":"<code>after_load()</code>  <code>classmethod</code>","text":"<p>Hook executed at the end of the load method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef after_load(cls):\n\"\"\"Hook executed at the end of the load method.\"\"\"\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.after_save","title":"<code>after_save()</code>","text":"<p>Hook executed at the end of the save method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def after_save(self):\n\"\"\"Hook executed at the end of the save method.\"\"\"\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.before_load","title":"<code>before_load()</code>  <code>classmethod</code>","text":"<p>Hook executed at the beggining of the load method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef before_load(cls):\n\"\"\"Hook executed at the beggining of the load method.\"\"\"\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.before_save","title":"<code>before_save()</code>","text":"<p>Hook executed at the beggining of the save method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def before_save(self):\n\"\"\"Hook executed at the beggining of the save method.\"\"\"\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.load","title":"<code>load(path, pickle_dump_kwargs=None)</code>  <code>classmethod</code>","text":"<p>Load a VIPicklable instance.</p> <p>Load a VIPicklable instance and all loadable attributes from a file or folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>additionnal arguments to be pass to load_instance method. Default to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load a VIPicklable instance and all loadable attributes from a file or folder.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n            load_instance method. Default to None.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.load_instance","title":"<code>load_instance(path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a VIPicklable instance.</p> <p>Load an instance from a file or folder without unpicklable attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>kwargs</code> <code>dict</code> <p>Additional parameters. Default to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load_instance(cls, path: Union[str, Path], **kwargs) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load an instance from a file or folder without unpicklable attributes.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        kwargs (dict, optional): Additional parameters. Default to {}.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nwith open(path, \"rb\") as f:\nreturn pickle.load(f, **kwargs)\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.load_pickle_blacklisted","title":"<code>load_pickle_blacklisted(path)</code>","text":"<p>Try to unpickle excluded attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <p>Returns:</p> Type Description <code>Dict[str, Exception]</code> <p>Dict[str, Exception]: A dictionary of attributes that could not be loaded and corresponding exceptions raised</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def load_pickle_blacklisted(self, path: Union[str, Path]) -&gt; Dict[str, Exception]:\n\"\"\"Try to unpickle excluded attributes.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n    Returns:\n        Dict[str, Exception]: A dictionary of attributes that could not be loaded\n            and corresponding exceptions raised\n    \"\"\"\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, RESTORE_METHOD_PATTERN.format(attribute))(path)\nexcept RestoreAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be restored\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be unpickled since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.save","title":"<code>save(path, pickle_dump_kwargs=None, json_dump_kwargs=None, overwrite=True)</code>","text":"<p>Save the object instance in a dedicated directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the directory</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to pickle.dump method. Defaults to None.</p> <code>None</code> <code>json_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to json.dump method. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n    Args:\n        path (Union[str, Path]): Path to the directory\n        pickle_dump_kwargs (dict, optional): kwargs to be passed to\n            pickle.dump method. Defaults to None.\n        json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n            Defaults to None.\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n    \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.save_config","title":"<code>save_config(path, overwrite=True, option=orjson.OPT_INDENT_2, default=Ellipsis)</code>","text":"<p>Save the instance configuration attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save the current instance config file</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> <code>option</code> <code>int</code> <p>ORJson options. See orjson documentation. Defaults to orjson.OPT_INDENT_2.</p> <code>orjson.OPT_INDENT_2</code> <code>default</code> <code>Callable</code> <p>To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.</p> <code>Ellipsis</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_config(\nself,\npath: Union[str, Path],\noverwrite: bool = True,\noption: Optional[int] = orjson.OPT_INDENT_2,\ndefault: Optional[Callable[[Any], Any]] = ...,\n):\n\"\"\"Save the instance configuration attributes.\n    Args:\n        path (Union[str, Path]): path to a folder where to save the current instance\n            config file\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n        option (int, optional): ORJson options.\n            See [orjson documentation](https://github.com/ijl/orjson).\n            Defaults to orjson.OPT_INDENT_2.\n        default (Callable): To serialize a subclass or arbitrary types, specify\n            default as a callable that returns a supported type. default may be a\n            function, lambda, or callable class instance. To specify that a type was\n            not handled by default, raise an exception such as TypeError.\n    \"\"\"\nif not self.CONFIG_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.CONFIG_NAME is empty so the configuration \"\nf\"dict will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.CONFIG_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\nf.write(\norjson.dumps(self.configurations, default=default, option=option)\n)\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.save_instance","title":"<code>save_instance(path, overwrite=True, **kwargs)</code>","text":"<p>Save the current instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save the current instance</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Additional parameters. Default to {}.</p> <code>{}</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_instance(self, path: Union[str, Path], overwrite: bool = True, **kwargs):\n\"\"\"Save the current instance.\n    Args:\n        path (Union[str, Path]): path to a folder where to save the current instance\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n        kwargs (dict, optional): Additional parameters. Default to {}.\n    \"\"\"\nif not self.PICKLE_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.PICKLE_NAME is empty so the instance \"\nf\"will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.PICKLE_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\npickle.dump(self, f, **kwargs)\n</code></pre>"},{"location":"reference/#vipickle.mixin.VIPicklable.save_pickle_blacklisted","title":"<code>save_pickle_blacklisted(path, overwrite=True)</code>","text":"<p>Try to save excluded attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save blacklisted attributes</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Exception]</code> <p>Dict[str, Exception]: A dictionary of attributes that could not be saved and corresponding exceptions raised</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_pickle_blacklisted(\nself, path: Union[str, Path], overwrite: bool = True\n) -&gt; Dict[str, Exception]:\n\"\"\"Try to save excluded attributes.\n    Args:\n        path (Union[str, Path]): path to a folder where to save blacklisted\n            attributes\n        overwrite (bool, optional): If True, overwrite the folder if it exists\n    Returns:\n        Dict[str, Exception]: A dictionary of attributes that could not be saved\n            and corresponding exceptions raised\n    \"\"\"\npath = create_folder(path)\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, DUMP_METHOD_PATTERN.format(attribute))(\npath, overwrite=overwrite\n)\nexcept DumpAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be dumped\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be dumped since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/#vipickle.create_folder","title":"<code>create_folder(path, exist_ok=True, parents=True)</code>","text":"<p>Create a folder if it does not exists and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the folder</p> required <code>exist_ok</code> <code>bool</code> <p>If False raise an error if the folder already exists. Defaults to True.</p> <code>True</code> <code>parents</code> <code>bool</code> <p>If True, also creates parent folders. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the created folder</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/save_utils.py</code> <pre><code>def create_folder(\npath: Union[str, Path], exist_ok: bool = True, parents: bool = True\n) -&gt; Path:\n\"\"\"Create a folder if it does not exists and returns it.\n    Args:\n        path (Union[str, Path]): Path to the folder\n        exist_ok (bool, optional): If False raise an error if the folder already exists.\n            Defaults to True.\n        parents (bool, optional): If True, also creates parent folders.\n            Defaults to True.\n    Returns:\n        Path: Path to the created folder\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\npath.mkdir(exist_ok=exist_ok, parents=parents)\nreturn path\n</code></pre>"},{"location":"features/blacklist/","title":"Blacklisting","text":""},{"location":"features/blacklist/#specifying-attributes-that-should-not-be-pickled","title":"Specifying attributes that should not be pickled","text":"<p>The main feature of <code>vipickle</code> is the ability to pickle any object thanks to a <code>PICKLE_BLACKLIST</code> class attribute :</p> <pre><code>from vipickle import VIPicklable\nclass MyClass(VIPicklable):\nPICKLE_BLACKLIST = [\"unpicklable_attribute\"]\ndef __init__(self):\nself.unpicklable_attribute = \"do_not_pickle\"\n</code></pre> <p>All attributes specified in <code>PICKLE_BLACKLIST</code> will no be included in the pickled file :</p> <pre><code>&gt;&gt;&gt; import pickle\n&gt;&gt;&gt;\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; assert obj.unpicklable_attribute == \"do_not_pickle\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; with open(\"obj.pkl\", \"wb\") as f:\n...    pickle.dump(obj, f)\n...\n&gt;&gt;&gt; with open(\"obj.pkl\", \"rb\") as f:\n...    obj = pickle.load(f)\n...\n&gt;&gt;&gt; obj.unpicklable_attribute\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'MyClass' object has no attribute 'unpicklable_attribute'\n</code></pre>"},{"location":"features/blacklist/#inheritance","title":"Inheritance","text":"<p>As any class attribute <code>PICKLE_BLACKLIST</code> will be inherited by all subclasses.</p> <p>It would be annoying to redefine <code>PICKLE_BLACKLIST</code> in each subclasses to add or remove some attributes from the list so <code>vipickle</code> introduce two class attributes for doing so</p>"},{"location":"features/blacklist/#pickle_blacklist_add","title":"<code>PICKLE_BLACKLIST_ADD</code>","text":"<pre><code>class MySubClass(MyClass):\nPICKLE_BLACKLIST_ADD = [\"another_unpicklable_attribute\"]\ndef __init__(self):\nsuper(MySubClass, self).__init__()\nself.another_unpicklable_attribute = \"do_not_pickle\"\n</code></pre>"},{"location":"features/blacklist/#pickle_blacklist_remove","title":"<code>PICKLE_BLACKLIST_REMOVE</code>","text":"<pre><code>class MySubSubClass(MySubClass):\nPICKLE_BLACKLIST_REMOVE = [\"unpicklable_attribute\"]\ndef __init__(self):\nsuper(MySubSubClass, self).__init__()\n</code></pre> <p>Warning</p> <p>If <code>PICKLE_BLACKLIST</code> is present, neither <code>PICKLE_BLACKLIST_ADD</code> nor <code>PICKLE_BLACKLIST_REMOVE</code> will be taken into account</p>"},{"location":"features/config/","title":"Config file","text":""},{"location":"features/config/#configuration-file","title":"Configuration file","text":"<p>It can be very handy to have save some attributes in a JSON file (which is human readable) so <code>vipickle</code> helps you with that :</p> <pre><code>from vipickle import VIPicklable\nclass MyClass(VIPicklable):\nCONFIG_ITEMS = [\"param\"]\ndef __init__(self):\nself.param = 0.1\n</code></pre> <p>When a <code>MyClass</code> is saved thanks to the <code>save</code> method, a <code>config.json</code> is created with all specified attributes</p> <pre><code>&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; obj.save(\"dir\")\n</code></pre> dir/config.json<pre><code>{\n\"param\": 0.1\n}\n</code></pre> <p><code>VIPicklable</code> have a <code>configurations</code> dict property that contains all attributes listed in <code>CONFIG_ITEMS</code></p>"},{"location":"features/config/#inheritance","title":"Inheritance","text":"<p>Just like the attribute <code>PICKLE_BLACKLIST</code>, <code>CONFIG_ITEMS</code> will be inherited by all subclasses.</p> <p>It would be annoying to redefine <code>CONFIG_ITEMS</code> in each subclasses to add or remove some attributes from the list so <code>vipickle</code> introduce two class attributes for doing so</p>"},{"location":"features/config/#config_items_add","title":"<code>CONFIG_ITEMS_ADD</code>","text":"<pre><code>class MySubClass(MyClass):\nCONFIG_ITEMS_ADD = [\"another_config_attribute\"]\ndef __init__(self):\nsuper(MySubClass, self).__init__()\nself.another_config_attribute = \"param\"\n</code></pre>"},{"location":"features/config/#config_items_remove","title":"<code>CONFIG_ITEMS_REMOVE</code>","text":"<pre><code>class MySubSubClass(MySubClass):\nCONFIG_ITEMS_REMOVE = [\"another_config_attribute\"]\n</code></pre> <p>Warning</p> <p>If <code>CONFIG_ITEMS</code> is present, neither <code>CONFIG_ITEMS_ADD</code> nor <code>CONFIG_ITEMS_REMOVE</code> will be taken into account</p>"},{"location":"features/loading/","title":"Loading","text":""},{"location":"features/loading/#loading-an-vipicklable-object","title":"Loading an VIPicklable object","text":"<p><code>VIPicklable</code> objects have a <code>load method</code> for loading an object instance :</p> <pre><code>&gt;&gt;&gt; class MyClass(VIPicklable):\n...    PICKLE_BLACKLIST = [\"unpicklable_attribute\"]\n...\n...    def __init__(self):\n...        self.unpicklable_attribute = \"do_not_pickle\"\n...\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; obj.save(\"folder\")\n&gt;&gt;&gt; obj = MyClass.load(\"folder\")\n</code></pre> VIPicklable.load <p>Load a VIPicklable instance.</p> <p>Load a VIPicklable instance and all loadable attributes from a file or folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>additionnal arguments to be pass to load_instance method. Default to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load a VIPicklable instance and all loadable attributes from a file or folder.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n            load_instance method. Default to None.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n</code></pre>"},{"location":"features/loading/#vipickle.mixin.VIPicklable.load","title":"Loading","text":""},{"location":"features/loading/#load-hooks","title":"Load hooks","text":"<p>Under the hood, the load method does the following :</p> <pre><code>stateDiagram-v2\n    [*] --&gt; self.before_load()\n    self.before_load() --&gt; self.load_instance()\n    self.load_instance() --&gt; self.load_pickle_blacklisted()\n    self.load_pickle_blacklisted() --&gt; self.after_load()\n    self.after_load() --&gt; [*]</code></pre> <p>One can redefine any of these methods to personnalise the saving process :</p> <ul> <li>before_load</li> <li>load_instance</li> <li>load_pickle_blacklisted</li> <li>after_load</li> </ul>"},{"location":"features/saving/","title":"Saving","text":""},{"location":"features/saving/#saving-a-vipicklable-object","title":"Saving a VIPicklable object","text":"<p><code>VIPicklable</code> objects have a <code>save method</code> for saving an object instance :</p> <pre><code>&gt;&gt;&gt; class MyClass(VIPicklable):\n...    PICKLE_BLACKLIST = [\"unpicklable_attribute\"]\n...\n...    def __init__(self):\n...        self.unpicklable_attribute = \"do_not_pickle\"\n...\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; obj.save(\"folder\")\n</code></pre> VIPicklable.save <p>Save the object instance in a dedicated directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the directory</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to pickle.dump method. Defaults to None.</p> <code>None</code> <code>json_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to json.dump method. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n    Args:\n        path (Union[str, Path]): Path to the directory\n        pickle_dump_kwargs (dict, optional): kwargs to be passed to\n            pickle.dump method. Defaults to None.\n        json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n            Defaults to None.\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n    \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\n</code></pre>"},{"location":"features/saving/#vipickle.mixin.VIPicklable.save","title":"Saving","text":""},{"location":"features/saving/#save-hooks","title":"Save hooks","text":"<p>Under the hood, the save method does the following :</p> <pre><code>stateDiagram-v2\n    [*] --&gt; self.before_save()\n    self.before_save() --&gt; self.save_instance()\n    self.save_instance() --&gt; self.save_config()\n    self.save_config() --&gt; self.save_pickle_blacklisted()\n    self.save_pickle_blacklisted() --&gt; self.after_save()\n    self.after_save() --&gt; [*]</code></pre> <p>One can redefine any of these methods to personnalise the saving process :</p> <ul> <li>before_save</li> <li>save_instance</li> <li>save_config</li> <li>save_pickle_blacklisted</li> <li>after_save</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>vipickle<ul> <li>_version</li> <li>errors</li> <li>mixin</li> <li>save_utils</li> </ul> </li> </ul>"},{"location":"reference/vipickle/","title":"vipickle","text":"<p>VIPickle.</p> <p>VIPickle make any object picklable by specifying which attribute to blacklist when pickling and how to dump and recover them.</p>"},{"location":"reference/vipickle/#vipickle.DumpAttributeError","title":"<code>DumpAttributeError</code>","text":"<p>         Bases: <code>AttributeError</code></p> <p>Use to indicate that the dumping method is not implemented.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/errors.py</code> <pre><code>class DumpAttributeError(AttributeError):\n\"\"\"Use to indicate that the dumping method is not implemented.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/#vipickle.MetaVIPicklable","title":"<code>MetaVIPicklable</code>","text":"<p>         Bases: <code>type</code></p> <p>Metaclass for VIPicklable.</p> <p>This metaclass is aimed to be used with VIPicklable class. It add the functionality to inherit attributes from the parent classes. Which is usefull for adding or removing attributes from PICKLE_BLACKLIST and CONFIG_ITEMS.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>class MetaVIPicklable(type):\n\"\"\"Metaclass for VIPicklable.\n    This metaclass is aimed to be used with VIPicklable class. It add the functionality\n    to inherit attributes from the parent classes. Which is usefull for adding or\n    removing attributes from PICKLE_BLACKLIST and CONFIG_ITEMS.\n    \"\"\"\ndef __new__(cls, name: str, parents: tuple, attributes: dict):\n\"\"\"Metaclass constructor.\n        Construct CONFIG_ITEMS and PICKLE_BLACKLIST.\n        Args:\n            name (str): Name of the class\n            parents (tuple): Parent classes\n            attributes (dict): Class attributes\n        \"\"\"\nfor prefix in (\"PICKLE_BLACKLIST\", \"CONFIG_ITEMS\"):\n# If the class has a prefix attribute, it will be used as it is\n# we convert it to a set to prevent duplicated values\nif prefix in attributes:\npickle_blacklist = {key for key in attributes[prefix]}\n# Otherwise the prefix attribute will be created from the parent classes\n# prefix attributes and the {prefix}_ADD and {prefix}_REMOVE attributes\nelse:\npickle_blacklist = set()\n# First we get the union of all pickle_blacklist of the parents\nfor parent in parents:\nif issubclass(parent, VIPicklable):\npickle_blacklist = pickle_blacklist.union(\ngetattr(parent, prefix, set())\n)\n# Then we add attributes from {prefix}_ADD\npickle_blacklist = pickle_blacklist.union(\nattributes.get(f\"{prefix}_ADD\", set())\n)\n# and we remove attributes from {prefix}_REMOVE\npickle_blacklist = pickle_blacklist.difference(\nattributes.get(f\"{prefix}_REMOVE\", set())\n)\n# Finnaly, {prefix} is converted to a tuple for immutablity\nattributes[prefix] = tuple(sorted(pickle_blacklist))\nreturn super().__new__(cls, name, parents, attributes)\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.MetaVIPicklable.__new__","title":"<code>__new__(name, parents, attributes)</code>","text":"<p>Metaclass constructor.</p> <p>Construct CONFIG_ITEMS and PICKLE_BLACKLIST.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the class</p> required <code>parents</code> <code>tuple</code> <p>Parent classes</p> required <code>attributes</code> <code>dict</code> <p>Class attributes</p> required Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def __new__(cls, name: str, parents: tuple, attributes: dict):\n\"\"\"Metaclass constructor.\n    Construct CONFIG_ITEMS and PICKLE_BLACKLIST.\n    Args:\n        name (str): Name of the class\n        parents (tuple): Parent classes\n        attributes (dict): Class attributes\n    \"\"\"\nfor prefix in (\"PICKLE_BLACKLIST\", \"CONFIG_ITEMS\"):\n# If the class has a prefix attribute, it will be used as it is\n# we convert it to a set to prevent duplicated values\nif prefix in attributes:\npickle_blacklist = {key for key in attributes[prefix]}\n# Otherwise the prefix attribute will be created from the parent classes\n# prefix attributes and the {prefix}_ADD and {prefix}_REMOVE attributes\nelse:\npickle_blacklist = set()\n# First we get the union of all pickle_blacklist of the parents\nfor parent in parents:\nif issubclass(parent, VIPicklable):\npickle_blacklist = pickle_blacklist.union(\ngetattr(parent, prefix, set())\n)\n# Then we add attributes from {prefix}_ADD\npickle_blacklist = pickle_blacklist.union(\nattributes.get(f\"{prefix}_ADD\", set())\n)\n# and we remove attributes from {prefix}_REMOVE\npickle_blacklist = pickle_blacklist.difference(\nattributes.get(f\"{prefix}_REMOVE\", set())\n)\n# Finnaly, {prefix} is converted to a tuple for immutablity\nattributes[prefix] = tuple(sorted(pickle_blacklist))\nreturn super().__new__(cls, name, parents, attributes)\n</code></pre>"},{"location":"reference/vipickle/#vipickle.RestoreAttributeError","title":"<code>RestoreAttributeError</code>","text":"<p>         Bases: <code>AttributeError</code></p> <p>Use to indicate that the restoring method is not implemented.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/errors.py</code> <pre><code>class RestoreAttributeError(AttributeError):\n\"\"\"Use to indicate that the restoring method is not implemented.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/#vipickle.VIPicklable","title":"<code>VIPicklable</code>","text":"<p>VIPicklable main class.</p> <p>Inherit from this class and define attributes to blacklist and the ones to add to the object configuration dict.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>class VIPicklable(metaclass=MetaVIPicklable):\n\"\"\"VIPicklable main class.\n    Inherit from this class and define attributes to blacklist and the ones to add to\n    the object configuration dict.\n    \"\"\"\nPICKLE_NAME: str = \"archive.pkl\"\nPICKLE_BLACKLIST: Iterable[str] = ()\nPICKLE_BLACKLIST_ADD: Iterable[str] = ()\nPICKLE_BLACKLIST_REMOVE: Iterable[str] = ()\nCONFIG_NAME: str = \"config.json\"\nCONFIG_ITEMS: Iterable[str] = ()\nCONFIG_ITEMS_ADD: Iterable[str] = ()\nCONFIG_ITEMS_REMOVE: Iterable[str] = ()\n@property\ndef configurations(self) -&gt; dict:\n\"\"\"A configuration dict used to show important attributes.\n        Returns:\n            dict: configuration dict\n        \"\"\"\nreturn {\nkey: getattr(self, key) for key in self.CONFIG_ITEMS if hasattr(self, key)\n}\ndef __getstate__(self):\n\"\"\"Pickle all attributes except the ones listed in PICKLE_BLACKLIST.\"\"\"\nreturn {\nattribute: state\nfor attribute, state in self.__dict__.items()\nif attribute not in self.PICKLE_BLACKLIST\n}\ndef save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n        Args:\n            path (Union[str, Path]): Path to the directory\n            pickle_dump_kwargs (dict, optional): kwargs to be passed to\n                pickle.dump method. Defaults to None.\n            json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n                Defaults to None.\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n        \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\ndef before_save(self):\n\"\"\"Hook executed at the beggining of the save method.\"\"\"\ndef after_save(self):\n\"\"\"Hook executed at the end of the save method.\"\"\"\ndef save_instance(self, path: Union[str, Path], overwrite: bool = True, **kwargs):\n\"\"\"Save the current instance.\n        Args:\n            path (Union[str, Path]): path to a folder where to save the current instance\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n            kwargs (dict, optional): Additional parameters. Default to {}.\n        \"\"\"\nif not self.PICKLE_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.PICKLE_NAME is empty so the instance \"\nf\"will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.PICKLE_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\npickle.dump(self, f, **kwargs)\ndef save_config(\nself,\npath: Union[str, Path],\noverwrite: bool = True,\noption: Optional[int] = orjson.OPT_INDENT_2,\ndefault: Optional[Callable[[Any], Any]] = ...,\n):\n\"\"\"Save the instance configuration attributes.\n        Args:\n            path (Union[str, Path]): path to a folder where to save the current instance\n                config file\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n            option (int, optional): ORJson options.\n                See [orjson documentation](https://github.com/ijl/orjson).\n                Defaults to orjson.OPT_INDENT_2.\n            default (Callable): To serialize a subclass or arbitrary types, specify\n                default as a callable that returns a supported type. default may be a\n                function, lambda, or callable class instance. To specify that a type was\n                not handled by default, raise an exception such as TypeError.\n        \"\"\"\nif not self.CONFIG_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.CONFIG_NAME is empty so the configuration \"\nf\"dict will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.CONFIG_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\nf.write(\norjson.dumps(self.configurations, default=default, option=option)\n)\ndef save_pickle_blacklisted(\nself, path: Union[str, Path], overwrite: bool = True\n) -&gt; Dict[str, Exception]:\n\"\"\"Try to save excluded attributes.\n        Args:\n            path (Union[str, Path]): path to a folder where to save blacklisted\n                attributes\n            overwrite (bool, optional): If True, overwrite the folder if it exists\n        Returns:\n            Dict[str, Exception]: A dictionary of attributes that could not be saved\n                and corresponding exceptions raised\n        \"\"\"\npath = create_folder(path)\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, DUMP_METHOD_PATTERN.format(attribute))(\npath, overwrite=overwrite\n)\nexcept DumpAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be dumped\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be dumped since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n@classmethod\ndef load_instance(cls, path: Union[str, Path], **kwargs) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n        Load an instance from a file or folder without unpicklable attributes.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n            kwargs (dict, optional): Additional parameters. Default to {}.\n        Raises:\n            FileNotFoundError: Pickle file not found\n        Returns:\n            VIPicklable: The instance object\n        \"\"\"\nwith open(path, \"rb\") as f:\nreturn pickle.load(f, **kwargs)\n@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n        Load a VIPicklable instance and all loadable attributes from a file or folder.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n            pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n                load_instance method. Default to None.\n        Raises:\n            FileNotFoundError: Pickle file not found\n        Returns:\n            VIPicklable: The instance object\n        \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n@classmethod\ndef before_load(cls):\n\"\"\"Hook executed at the beggining of the load method.\"\"\"\n@classmethod\ndef after_load(cls):\n\"\"\"Hook executed at the end of the load method.\"\"\"\ndef load_pickle_blacklisted(self, path: Union[str, Path]) -&gt; Dict[str, Exception]:\n\"\"\"Try to unpickle excluded attributes.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n        Returns:\n            Dict[str, Exception]: A dictionary of attributes that could not be loaded\n                and corresponding exceptions raised\n        \"\"\"\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, RESTORE_METHOD_PATTERN.format(attribute))(path)\nexcept RestoreAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be restored\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be unpickled since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.configurations","title":"<code>configurations: dict</code>  <code>property</code>","text":"<p>A configuration dict used to show important attributes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>configuration dict</p>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Pickle all attributes except the ones listed in PICKLE_BLACKLIST.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def __getstate__(self):\n\"\"\"Pickle all attributes except the ones listed in PICKLE_BLACKLIST.\"\"\"\nreturn {\nattribute: state\nfor attribute, state in self.__dict__.items()\nif attribute not in self.PICKLE_BLACKLIST\n}\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.after_load","title":"<code>after_load()</code>  <code>classmethod</code>","text":"<p>Hook executed at the end of the load method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef after_load(cls):\n\"\"\"Hook executed at the end of the load method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.after_save","title":"<code>after_save()</code>","text":"<p>Hook executed at the end of the save method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def after_save(self):\n\"\"\"Hook executed at the end of the save method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.before_load","title":"<code>before_load()</code>  <code>classmethod</code>","text":"<p>Hook executed at the beggining of the load method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef before_load(cls):\n\"\"\"Hook executed at the beggining of the load method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.before_save","title":"<code>before_save()</code>","text":"<p>Hook executed at the beggining of the save method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def before_save(self):\n\"\"\"Hook executed at the beggining of the save method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.load","title":"<code>load(path, pickle_dump_kwargs=None)</code>  <code>classmethod</code>","text":"<p>Load a VIPicklable instance.</p> <p>Load a VIPicklable instance and all loadable attributes from a file or folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>additionnal arguments to be pass to load_instance method. Default to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load a VIPicklable instance and all loadable attributes from a file or folder.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n            load_instance method. Default to None.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.load_instance","title":"<code>load_instance(path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a VIPicklable instance.</p> <p>Load an instance from a file or folder without unpicklable attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>kwargs</code> <code>dict</code> <p>Additional parameters. Default to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load_instance(cls, path: Union[str, Path], **kwargs) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load an instance from a file or folder without unpicklable attributes.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        kwargs (dict, optional): Additional parameters. Default to {}.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nwith open(path, \"rb\") as f:\nreturn pickle.load(f, **kwargs)\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.load_pickle_blacklisted","title":"<code>load_pickle_blacklisted(path)</code>","text":"<p>Try to unpickle excluded attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <p>Returns:</p> Type Description <code>Dict[str, Exception]</code> <p>Dict[str, Exception]: A dictionary of attributes that could not be loaded and corresponding exceptions raised</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def load_pickle_blacklisted(self, path: Union[str, Path]) -&gt; Dict[str, Exception]:\n\"\"\"Try to unpickle excluded attributes.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n    Returns:\n        Dict[str, Exception]: A dictionary of attributes that could not be loaded\n            and corresponding exceptions raised\n    \"\"\"\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, RESTORE_METHOD_PATTERN.format(attribute))(path)\nexcept RestoreAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be restored\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be unpickled since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.save","title":"<code>save(path, pickle_dump_kwargs=None, json_dump_kwargs=None, overwrite=True)</code>","text":"<p>Save the object instance in a dedicated directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the directory</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to pickle.dump method. Defaults to None.</p> <code>None</code> <code>json_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to json.dump method. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n    Args:\n        path (Union[str, Path]): Path to the directory\n        pickle_dump_kwargs (dict, optional): kwargs to be passed to\n            pickle.dump method. Defaults to None.\n        json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n            Defaults to None.\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n    \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.save_config","title":"<code>save_config(path, overwrite=True, option=orjson.OPT_INDENT_2, default=Ellipsis)</code>","text":"<p>Save the instance configuration attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save the current instance config file</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> <code>option</code> <code>int</code> <p>ORJson options. See orjson documentation. Defaults to orjson.OPT_INDENT_2.</p> <code>orjson.OPT_INDENT_2</code> <code>default</code> <code>Callable</code> <p>To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.</p> <code>Ellipsis</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_config(\nself,\npath: Union[str, Path],\noverwrite: bool = True,\noption: Optional[int] = orjson.OPT_INDENT_2,\ndefault: Optional[Callable[[Any], Any]] = ...,\n):\n\"\"\"Save the instance configuration attributes.\n    Args:\n        path (Union[str, Path]): path to a folder where to save the current instance\n            config file\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n        option (int, optional): ORJson options.\n            See [orjson documentation](https://github.com/ijl/orjson).\n            Defaults to orjson.OPT_INDENT_2.\n        default (Callable): To serialize a subclass or arbitrary types, specify\n            default as a callable that returns a supported type. default may be a\n            function, lambda, or callable class instance. To specify that a type was\n            not handled by default, raise an exception such as TypeError.\n    \"\"\"\nif not self.CONFIG_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.CONFIG_NAME is empty so the configuration \"\nf\"dict will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.CONFIG_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\nf.write(\norjson.dumps(self.configurations, default=default, option=option)\n)\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.save_instance","title":"<code>save_instance(path, overwrite=True, **kwargs)</code>","text":"<p>Save the current instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save the current instance</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Additional parameters. Default to {}.</p> <code>{}</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_instance(self, path: Union[str, Path], overwrite: bool = True, **kwargs):\n\"\"\"Save the current instance.\n    Args:\n        path (Union[str, Path]): path to a folder where to save the current instance\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n        kwargs (dict, optional): Additional parameters. Default to {}.\n    \"\"\"\nif not self.PICKLE_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.PICKLE_NAME is empty so the instance \"\nf\"will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.PICKLE_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\npickle.dump(self, f, **kwargs)\n</code></pre>"},{"location":"reference/vipickle/#vipickle.mixin.VIPicklable.save_pickle_blacklisted","title":"<code>save_pickle_blacklisted(path, overwrite=True)</code>","text":"<p>Try to save excluded attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save blacklisted attributes</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Exception]</code> <p>Dict[str, Exception]: A dictionary of attributes that could not be saved and corresponding exceptions raised</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_pickle_blacklisted(\nself, path: Union[str, Path], overwrite: bool = True\n) -&gt; Dict[str, Exception]:\n\"\"\"Try to save excluded attributes.\n    Args:\n        path (Union[str, Path]): path to a folder where to save blacklisted\n            attributes\n        overwrite (bool, optional): If True, overwrite the folder if it exists\n    Returns:\n        Dict[str, Exception]: A dictionary of attributes that could not be saved\n            and corresponding exceptions raised\n    \"\"\"\npath = create_folder(path)\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, DUMP_METHOD_PATTERN.format(attribute))(\npath, overwrite=overwrite\n)\nexcept DumpAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be dumped\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be dumped since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/vipickle/#vipickle.create_folder","title":"<code>create_folder(path, exist_ok=True, parents=True)</code>","text":"<p>Create a folder if it does not exists and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the folder</p> required <code>exist_ok</code> <code>bool</code> <p>If False raise an error if the folder already exists. Defaults to True.</p> <code>True</code> <code>parents</code> <code>bool</code> <p>If True, also creates parent folders. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the created folder</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/save_utils.py</code> <pre><code>def create_folder(\npath: Union[str, Path], exist_ok: bool = True, parents: bool = True\n) -&gt; Path:\n\"\"\"Create a folder if it does not exists and returns it.\n    Args:\n        path (Union[str, Path]): Path to the folder\n        exist_ok (bool, optional): If False raise an error if the folder already exists.\n            Defaults to True.\n        parents (bool, optional): If True, also creates parent folders.\n            Defaults to True.\n    Returns:\n        Path: Path to the created folder\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\npath.mkdir(exist_ok=exist_ok, parents=parents)\nreturn path\n</code></pre>"},{"location":"reference/vipickle/_version/","title":"_version","text":""},{"location":"reference/vipickle/errors/","title":"errors","text":"<p>VIPickle errors.</p> <p>VIPickle custom errors</p>"},{"location":"reference/vipickle/errors/#vipickle.errors.DumpAttributeError","title":"<code>DumpAttributeError</code>","text":"<p>         Bases: <code>AttributeError</code></p> <p>Use to indicate that the dumping method is not implemented.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/errors.py</code> <pre><code>class DumpAttributeError(AttributeError):\n\"\"\"Use to indicate that the dumping method is not implemented.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/errors/#vipickle.errors.RestoreAttributeError","title":"<code>RestoreAttributeError</code>","text":"<p>         Bases: <code>AttributeError</code></p> <p>Use to indicate that the restoring method is not implemented.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/errors.py</code> <pre><code>class RestoreAttributeError(AttributeError):\n\"\"\"Use to indicate that the restoring method is not implemented.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/mixin/","title":"mixin","text":"<p>Mixin module.</p> <p>This module contains the main VIPickable class and its meta class.</p>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.MetaVIPicklable","title":"<code>MetaVIPicklable</code>","text":"<p>         Bases: <code>type</code></p> <p>Metaclass for VIPicklable.</p> <p>This metaclass is aimed to be used with VIPicklable class. It add the functionality to inherit attributes from the parent classes. Which is usefull for adding or removing attributes from PICKLE_BLACKLIST and CONFIG_ITEMS.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>class MetaVIPicklable(type):\n\"\"\"Metaclass for VIPicklable.\n    This metaclass is aimed to be used with VIPicklable class. It add the functionality\n    to inherit attributes from the parent classes. Which is usefull for adding or\n    removing attributes from PICKLE_BLACKLIST and CONFIG_ITEMS.\n    \"\"\"\ndef __new__(cls, name: str, parents: tuple, attributes: dict):\n\"\"\"Metaclass constructor.\n        Construct CONFIG_ITEMS and PICKLE_BLACKLIST.\n        Args:\n            name (str): Name of the class\n            parents (tuple): Parent classes\n            attributes (dict): Class attributes\n        \"\"\"\nfor prefix in (\"PICKLE_BLACKLIST\", \"CONFIG_ITEMS\"):\n# If the class has a prefix attribute, it will be used as it is\n# we convert it to a set to prevent duplicated values\nif prefix in attributes:\npickle_blacklist = {key for key in attributes[prefix]}\n# Otherwise the prefix attribute will be created from the parent classes\n# prefix attributes and the {prefix}_ADD and {prefix}_REMOVE attributes\nelse:\npickle_blacklist = set()\n# First we get the union of all pickle_blacklist of the parents\nfor parent in parents:\nif issubclass(parent, VIPicklable):\npickle_blacklist = pickle_blacklist.union(\ngetattr(parent, prefix, set())\n)\n# Then we add attributes from {prefix}_ADD\npickle_blacklist = pickle_blacklist.union(\nattributes.get(f\"{prefix}_ADD\", set())\n)\n# and we remove attributes from {prefix}_REMOVE\npickle_blacklist = pickle_blacklist.difference(\nattributes.get(f\"{prefix}_REMOVE\", set())\n)\n# Finnaly, {prefix} is converted to a tuple for immutablity\nattributes[prefix] = tuple(sorted(pickle_blacklist))\nreturn super().__new__(cls, name, parents, attributes)\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.MetaVIPicklable.__new__","title":"<code>__new__(name, parents, attributes)</code>","text":"<p>Metaclass constructor.</p> <p>Construct CONFIG_ITEMS and PICKLE_BLACKLIST.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the class</p> required <code>parents</code> <code>tuple</code> <p>Parent classes</p> required <code>attributes</code> <code>dict</code> <p>Class attributes</p> required Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def __new__(cls, name: str, parents: tuple, attributes: dict):\n\"\"\"Metaclass constructor.\n    Construct CONFIG_ITEMS and PICKLE_BLACKLIST.\n    Args:\n        name (str): Name of the class\n        parents (tuple): Parent classes\n        attributes (dict): Class attributes\n    \"\"\"\nfor prefix in (\"PICKLE_BLACKLIST\", \"CONFIG_ITEMS\"):\n# If the class has a prefix attribute, it will be used as it is\n# we convert it to a set to prevent duplicated values\nif prefix in attributes:\npickle_blacklist = {key for key in attributes[prefix]}\n# Otherwise the prefix attribute will be created from the parent classes\n# prefix attributes and the {prefix}_ADD and {prefix}_REMOVE attributes\nelse:\npickle_blacklist = set()\n# First we get the union of all pickle_blacklist of the parents\nfor parent in parents:\nif issubclass(parent, VIPicklable):\npickle_blacklist = pickle_blacklist.union(\ngetattr(parent, prefix, set())\n)\n# Then we add attributes from {prefix}_ADD\npickle_blacklist = pickle_blacklist.union(\nattributes.get(f\"{prefix}_ADD\", set())\n)\n# and we remove attributes from {prefix}_REMOVE\npickle_blacklist = pickle_blacklist.difference(\nattributes.get(f\"{prefix}_REMOVE\", set())\n)\n# Finnaly, {prefix} is converted to a tuple for immutablity\nattributes[prefix] = tuple(sorted(pickle_blacklist))\nreturn super().__new__(cls, name, parents, attributes)\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable","title":"<code>VIPicklable</code>","text":"<p>VIPicklable main class.</p> <p>Inherit from this class and define attributes to blacklist and the ones to add to the object configuration dict.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>class VIPicklable(metaclass=MetaVIPicklable):\n\"\"\"VIPicklable main class.\n    Inherit from this class and define attributes to blacklist and the ones to add to\n    the object configuration dict.\n    \"\"\"\nPICKLE_NAME: str = \"archive.pkl\"\nPICKLE_BLACKLIST: Iterable[str] = ()\nPICKLE_BLACKLIST_ADD: Iterable[str] = ()\nPICKLE_BLACKLIST_REMOVE: Iterable[str] = ()\nCONFIG_NAME: str = \"config.json\"\nCONFIG_ITEMS: Iterable[str] = ()\nCONFIG_ITEMS_ADD: Iterable[str] = ()\nCONFIG_ITEMS_REMOVE: Iterable[str] = ()\n@property\ndef configurations(self) -&gt; dict:\n\"\"\"A configuration dict used to show important attributes.\n        Returns:\n            dict: configuration dict\n        \"\"\"\nreturn {\nkey: getattr(self, key) for key in self.CONFIG_ITEMS if hasattr(self, key)\n}\ndef __getstate__(self):\n\"\"\"Pickle all attributes except the ones listed in PICKLE_BLACKLIST.\"\"\"\nreturn {\nattribute: state\nfor attribute, state in self.__dict__.items()\nif attribute not in self.PICKLE_BLACKLIST\n}\ndef save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n        Args:\n            path (Union[str, Path]): Path to the directory\n            pickle_dump_kwargs (dict, optional): kwargs to be passed to\n                pickle.dump method. Defaults to None.\n            json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n                Defaults to None.\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n        \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\ndef before_save(self):\n\"\"\"Hook executed at the beggining of the save method.\"\"\"\ndef after_save(self):\n\"\"\"Hook executed at the end of the save method.\"\"\"\ndef save_instance(self, path: Union[str, Path], overwrite: bool = True, **kwargs):\n\"\"\"Save the current instance.\n        Args:\n            path (Union[str, Path]): path to a folder where to save the current instance\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n            kwargs (dict, optional): Additional parameters. Default to {}.\n        \"\"\"\nif not self.PICKLE_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.PICKLE_NAME is empty so the instance \"\nf\"will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.PICKLE_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\npickle.dump(self, f, **kwargs)\ndef save_config(\nself,\npath: Union[str, Path],\noverwrite: bool = True,\noption: Optional[int] = orjson.OPT_INDENT_2,\ndefault: Optional[Callable[[Any], Any]] = ...,\n):\n\"\"\"Save the instance configuration attributes.\n        Args:\n            path (Union[str, Path]): path to a folder where to save the current instance\n                config file\n            overwrite (bool, optional): If True, overwrite the folder if it exists.\n            option (int, optional): ORJson options.\n                See [orjson documentation](https://github.com/ijl/orjson).\n                Defaults to orjson.OPT_INDENT_2.\n            default (Callable): To serialize a subclass or arbitrary types, specify\n                default as a callable that returns a supported type. default may be a\n                function, lambda, or callable class instance. To specify that a type was\n                not handled by default, raise an exception such as TypeError.\n        \"\"\"\nif not self.CONFIG_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.CONFIG_NAME is empty so the configuration \"\nf\"dict will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.CONFIG_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\nf.write(\norjson.dumps(self.configurations, default=default, option=option)\n)\ndef save_pickle_blacklisted(\nself, path: Union[str, Path], overwrite: bool = True\n) -&gt; Dict[str, Exception]:\n\"\"\"Try to save excluded attributes.\n        Args:\n            path (Union[str, Path]): path to a folder where to save blacklisted\n                attributes\n            overwrite (bool, optional): If True, overwrite the folder if it exists\n        Returns:\n            Dict[str, Exception]: A dictionary of attributes that could not be saved\n                and corresponding exceptions raised\n        \"\"\"\npath = create_folder(path)\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, DUMP_METHOD_PATTERN.format(attribute))(\npath, overwrite=overwrite\n)\nexcept DumpAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be dumped\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be dumped since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n@classmethod\ndef load_instance(cls, path: Union[str, Path], **kwargs) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n        Load an instance from a file or folder without unpicklable attributes.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n            kwargs (dict, optional): Additional parameters. Default to {}.\n        Raises:\n            FileNotFoundError: Pickle file not found\n        Returns:\n            VIPicklable: The instance object\n        \"\"\"\nwith open(path, \"rb\") as f:\nreturn pickle.load(f, **kwargs)\n@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n        Load a VIPicklable instance and all loadable attributes from a file or folder.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n            pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n                load_instance method. Default to None.\n        Raises:\n            FileNotFoundError: Pickle file not found\n        Returns:\n            VIPicklable: The instance object\n        \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n@classmethod\ndef before_load(cls):\n\"\"\"Hook executed at the beggining of the load method.\"\"\"\n@classmethod\ndef after_load(cls):\n\"\"\"Hook executed at the end of the load method.\"\"\"\ndef load_pickle_blacklisted(self, path: Union[str, Path]) -&gt; Dict[str, Exception]:\n\"\"\"Try to unpickle excluded attributes.\n        Args:\n            path (Union[str, Path]): Path to the pickle file\n        Returns:\n            Dict[str, Exception]: A dictionary of attributes that could not be loaded\n                and corresponding exceptions raised\n        \"\"\"\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, RESTORE_METHOD_PATTERN.format(attribute))(path)\nexcept RestoreAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be restored\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be unpickled since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.configurations","title":"<code>configurations: dict</code>  <code>property</code>","text":"<p>A configuration dict used to show important attributes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>configuration dict</p>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Pickle all attributes except the ones listed in PICKLE_BLACKLIST.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def __getstate__(self):\n\"\"\"Pickle all attributes except the ones listed in PICKLE_BLACKLIST.\"\"\"\nreturn {\nattribute: state\nfor attribute, state in self.__dict__.items()\nif attribute not in self.PICKLE_BLACKLIST\n}\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.after_load","title":"<code>after_load()</code>  <code>classmethod</code>","text":"<p>Hook executed at the end of the load method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef after_load(cls):\n\"\"\"Hook executed at the end of the load method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.after_save","title":"<code>after_save()</code>","text":"<p>Hook executed at the end of the save method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def after_save(self):\n\"\"\"Hook executed at the end of the save method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.before_load","title":"<code>before_load()</code>  <code>classmethod</code>","text":"<p>Hook executed at the beggining of the load method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef before_load(cls):\n\"\"\"Hook executed at the beggining of the load method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.before_save","title":"<code>before_save()</code>","text":"<p>Hook executed at the beggining of the save method.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def before_save(self):\n\"\"\"Hook executed at the beggining of the save method.\"\"\"\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.load","title":"<code>load(path, pickle_dump_kwargs=None)</code>  <code>classmethod</code>","text":"<p>Load a VIPicklable instance.</p> <p>Load a VIPicklable instance and all loadable attributes from a file or folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>additionnal arguments to be pass to load_instance method. Default to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load(\ncls,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\n) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load a VIPicklable instance and all loadable attributes from a file or folder.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        pickle_dump_kwargs (dict, optional): additionnal arguments to be pass to\n            load_instance method. Default to None.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif path.is_dir():\npickle_path = path / cls.PICKLE_NAME\nfolder_path = path\nelif path.is_file():\npickle_path = path\nfolder_path = path.parent\nelse:\nraise FileNotFoundError(f\"{path} not found\")\ncls.before_load()\nobj = cls.load_instance(pickle_path, **pickle_dump_kwargs)\nobj.load_pickle_blacklisted(folder_path)\nobj.after_load()\nreturn obj\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.load_instance","title":"<code>load_instance(path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a VIPicklable instance.</p> <p>Load an instance from a file or folder without unpicklable attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <code>kwargs</code> <code>dict</code> <p>Additional parameters. Default to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Pickle file not found</p> <p>Returns:</p> Name Type Description <code>VIPicklable</code> <code>VIPicklable</code> <p>The instance object</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>@classmethod\ndef load_instance(cls, path: Union[str, Path], **kwargs) -&gt; \"VIPicklable\":\n\"\"\"Load a VIPicklable instance.\n    Load an instance from a file or folder without unpicklable attributes.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n        kwargs (dict, optional): Additional parameters. Default to {}.\n    Raises:\n        FileNotFoundError: Pickle file not found\n    Returns:\n        VIPicklable: The instance object\n    \"\"\"\nwith open(path, \"rb\") as f:\nreturn pickle.load(f, **kwargs)\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.load_pickle_blacklisted","title":"<code>load_pickle_blacklisted(path)</code>","text":"<p>Try to unpickle excluded attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the pickle file</p> required <p>Returns:</p> Type Description <code>Dict[str, Exception]</code> <p>Dict[str, Exception]: A dictionary of attributes that could not be loaded and corresponding exceptions raised</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def load_pickle_blacklisted(self, path: Union[str, Path]) -&gt; Dict[str, Exception]:\n\"\"\"Try to unpickle excluded attributes.\n    Args:\n        path (Union[str, Path]): Path to the pickle file\n    Returns:\n        Dict[str, Exception]: A dictionary of attributes that could not be loaded\n            and corresponding exceptions raised\n    \"\"\"\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, RESTORE_METHOD_PATTERN.format(attribute))(path)\nexcept RestoreAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be restored\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be unpickled since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{RESTORE_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.save","title":"<code>save(path, pickle_dump_kwargs=None, json_dump_kwargs=None, overwrite=True)</code>","text":"<p>Save the object instance in a dedicated directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the directory</p> required <code>pickle_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to pickle.dump method. Defaults to None.</p> <code>None</code> <code>json_dump_kwargs</code> <code>dict</code> <p>kwargs to be passed to json.dump method. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save(\nself,\npath: Union[str, Path],\npickle_dump_kwargs: dict = None,\njson_dump_kwargs: dict = None,\noverwrite: bool = True,\n):\n\"\"\"Save the object instance in a dedicated directory.\n    Args:\n        path (Union[str, Path]): Path to the directory\n        pickle_dump_kwargs (dict, optional): kwargs to be passed to\n            pickle.dump method. Defaults to None.\n        json_dump_kwargs (dict, optional): kwargs to be passed to json.dump method.\n            Defaults to None.\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n    \"\"\"\n# Before save hook\nself.before_save()\npath = create_folder(path)\nif pickle_dump_kwargs is None:\npickle_dump_kwargs = {}\nif json_dump_kwargs is None:\njson_dump_kwargs = {}\nself.save_instance(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_config(path, overwrite=overwrite, **json_dump_kwargs)\nself.save_pickle_blacklisted(path, overwrite=overwrite)\n# After save hook\nself.after_save()\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.save_config","title":"<code>save_config(path, overwrite=True, option=orjson.OPT_INDENT_2, default=Ellipsis)</code>","text":"<p>Save the instance configuration attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save the current instance config file</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> <code>option</code> <code>int</code> <p>ORJson options. See orjson documentation. Defaults to orjson.OPT_INDENT_2.</p> <code>orjson.OPT_INDENT_2</code> <code>default</code> <code>Callable</code> <p>To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.</p> <code>Ellipsis</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_config(\nself,\npath: Union[str, Path],\noverwrite: bool = True,\noption: Optional[int] = orjson.OPT_INDENT_2,\ndefault: Optional[Callable[[Any], Any]] = ...,\n):\n\"\"\"Save the instance configuration attributes.\n    Args:\n        path (Union[str, Path]): path to a folder where to save the current instance\n            config file\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n        option (int, optional): ORJson options.\n            See [orjson documentation](https://github.com/ijl/orjson).\n            Defaults to orjson.OPT_INDENT_2.\n        default (Callable): To serialize a subclass or arbitrary types, specify\n            default as a callable that returns a supported type. default may be a\n            function, lambda, or callable class instance. To specify that a type was\n            not handled by default, raise an exception such as TypeError.\n    \"\"\"\nif not self.CONFIG_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.CONFIG_NAME is empty so the configuration \"\nf\"dict will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.CONFIG_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\nf.write(\norjson.dumps(self.configurations, default=default, option=option)\n)\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.save_instance","title":"<code>save_instance(path, overwrite=True, **kwargs)</code>","text":"<p>Save the current instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save the current instance</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Additional parameters. Default to {}.</p> <code>{}</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_instance(self, path: Union[str, Path], overwrite: bool = True, **kwargs):\n\"\"\"Save the current instance.\n    Args:\n        path (Union[str, Path]): path to a folder where to save the current instance\n        overwrite (bool, optional): If True, overwrite the folder if it exists.\n        kwargs (dict, optional): Additional parameters. Default to {}.\n    \"\"\"\nif not self.PICKLE_NAME:\nlogger.info(\nf\"{self.__class__.__name__}.PICKLE_NAME is empty so the instance \"\nf\"will not be saved\"\n)\nreturn\npath = create_folder(path)\nfilepath = path / self.PICKLE_NAME\nif overwrite or not filepath.exists():\nwith open(filepath, \"wb\") as f:\npickle.dump(self, f, **kwargs)\n</code></pre>"},{"location":"reference/vipickle/mixin/#vipickle.mixin.VIPicklable.save_pickle_blacklisted","title":"<code>save_pickle_blacklisted(path, overwrite=True)</code>","text":"<p>Try to save excluded attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to a folder where to save blacklisted attributes</p> required <code>overwrite</code> <code>bool</code> <p>If True, overwrite the folder if it exists</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Exception]</code> <p>Dict[str, Exception]: A dictionary of attributes that could not be saved and corresponding exceptions raised</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/mixin.py</code> <pre><code>def save_pickle_blacklisted(\nself, path: Union[str, Path], overwrite: bool = True\n) -&gt; Dict[str, Exception]:\n\"\"\"Try to save excluded attributes.\n    Args:\n        path (Union[str, Path]): path to a folder where to save blacklisted\n            attributes\n        overwrite (bool, optional): If True, overwrite the folder if it exists\n    Returns:\n        Dict[str, Exception]: A dictionary of attributes that could not be saved\n            and corresponding exceptions raised\n    \"\"\"\npath = create_folder(path)\nfailures = {}\nfor attribute in self.PICKLE_BLACKLIST:\ntry:\ngetattr(self, DUMP_METHOD_PATTERN.format(attribute))(\npath, overwrite=overwrite\n)\nexcept DumpAttributeError as e:\nlogger.warning(\nf\"{self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)} failed : \"\nf\"self.{attribute} could not be dumped\"\n)\nlogger.exception(e)\nfailures[attribute] = e\nexcept AttributeError as e:\nlogger.debug(\nf\"self.{attribute} count not be dumped since there is no \"\nf\"method {self.__class__.__name__}\"\nf\".{DUMP_METHOD_PATTERN.format(attribute)}\"\n)\nfailures[attribute] = e\nreturn failures\n</code></pre>"},{"location":"reference/vipickle/save_utils/","title":"save_utils","text":"<p>Saving utilities module.</p> <p>Module containing utilities functions for saving purpose.</p>"},{"location":"reference/vipickle/save_utils/#vipickle.save_utils.create_folder","title":"<code>create_folder(path, exist_ok=True, parents=True)</code>","text":"<p>Create a folder if it does not exists and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the folder</p> required <code>exist_ok</code> <code>bool</code> <p>If False raise an error if the folder already exists. Defaults to True.</p> <code>True</code> <code>parents</code> <code>bool</code> <p>If True, also creates parent folders. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the created folder</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/vipickle/save_utils.py</code> <pre><code>def create_folder(\npath: Union[str, Path], exist_ok: bool = True, parents: bool = True\n) -&gt; Path:\n\"\"\"Create a folder if it does not exists and returns it.\n    Args:\n        path (Union[str, Path]): Path to the folder\n        exist_ok (bool, optional): If False raise an error if the folder already exists.\n            Defaults to True.\n        parents (bool, optional): If True, also creates parent folders.\n            Defaults to True.\n    Returns:\n        Path: Path to the created folder\n    \"\"\"\nif isinstance(path, str):\npath = Path(path)\npath.mkdir(exist_ok=exist_ok, parents=parents)\nreturn path\n</code></pre>"}]}